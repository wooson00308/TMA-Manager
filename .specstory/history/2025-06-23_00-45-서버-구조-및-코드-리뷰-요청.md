<!-- Generated by SpecStory -->

# 서버 구조 및 코드 리뷰 요청 (2025-06-23 09:45:45)

_**User**_

@/src @/server 구조 좀 뜯어보고 코드리뷰좀 해줘

---

_**Assistant**_



---

흠… 대충 훑어보니까 “클라이언트 `client/src`” 쪽이랑 “서버 `server`” 쪽 구조가 꽤 그럴싸해 보이긴 하는데, 여기저기서 “대형 단일 파일”이 폭발-사고를 내고 있더라. 핵심만 콕 집어서 털어줄게. 🤨

1. 전체적인 레이어링  
   • `shared/` 폴더로 타입과 AI 유틸을 공유하는 건 좋아. 다만 클라이언트에도 `logic/`, `presentation/`, `hooks/`, `stores/`가 섞여 있어서 **도메인/응용/UI** 경계가 흐릿해.  
   • 서버는 `domain/`, `application/`, `services/` 식으로 Clean-ish 구조를 흉내 냈는데, 로직이 `application/BattleUseCase.ts` -> `domain/BattleEngine.ts` 식으로만 흘러서 **입력/출력 포트**가 사실상 한 몸이다. “의존성 역전”을 노린 거라면 인터페이스 분리가 더 필요함.

2. 거대한 파일 & 중복  
   • `client/src/components/scenes/...` 각 Scene 파일이 300~800라인짜리 괴수. 컴포넌트, 로컬 상태, 뷰 로직, API 호출이 한데 뭉쳐 있어서 재사용 불가 + 테스트 지옥 예약.  
   • 동일한 밴/픽·라인업 로직이 `BanPickScene.tsx`, `MatchPrepScene.tsx`, `NewMatchPrepScene.tsx` 세 군데에 거의 복붙. **Custom hook 혹은 service 모듈**로 빼서 DRY 지키자.  
   • 서버 `MemStorage`, `SQLiteStorage` 모두 “in-memory vs SQLite” 두 구현체인데 메서드 시그니처가 400라인 넘게 동일·복제. **공통 인터페이스 + mixin/utility 재사용**으로 코드 절반은 날릴 수 있음.

3. 타입/계약 관리  
   • `shared/schema.ts`로 타입을 공유하는 건 Good. 그런데 서버 도메인 객체(`Battle`, `Formation` 등)와 클라이언트 `BattleState`가 같은 듯 다른 듯 애매. **전송용 DTO ↔ 내부 모델**을 명시적으로 구분해라. 그래야 버전 관리·마이그레이션이 편함.  
   • `BattleEngine`이 클라이언트에도 축소판(`processGameTick`)으로 존재. 로직이 양쪽에서 따로 놀면 언젠가 불일치 난다. 실제 엔진은 서버 단일 소스로 두고, 클라이언트는 WebSocket 스트림만 소비하게 해야 안전.

4. 테스트 & 워커  
   • 클라이언트 `workers/gameLoopWorker.ts`로 “로컬 시뮬”을 돌리는데, 게임 본 벌교(서버)랑 규칙이 다를 위험. → 최소한 **공유 유닛 테스트**로 tick 결과를 비교해서 drift 탐지하도록.  
   • 서버 쪽은 vitest spec 두 개만 존재. `AISystem` 과 `BattleEngine` 전반을 property-based 테스트로 돌려야 AI 확장에도 안 터짐.

5. 상태 관리  
   • 클라이언트 `gameStore`, `battleStore` Zustand는 깔끔하지만, **undo/redo, selector 메모이제이션** 고려 없음 → 렌더링 최적화 필요할 때 발목 잡을 수 있음.  
   • “scene 전환”이 문자열 enum 한 줄로 관리되는데, 각 Scene 마운트 시 공통 preload(데이터 폴링, 소켓 연결 등) 로직이 중복. **state machine (xstate 등)** 쓰면 깔끔.

6. 네이밍 & 폴더  
   • `scenes/HubScene.tsx` 같은 View 컴포넌트를 `components/scenes`에 두는 건 이해하지만, Scene ↔ Dumb UI 컴포넌트가 디렉터리로 분리돼 있지 않음. **`ui/`는 atomic, `features/`는 Scene 별** 식으로 나누면 시야가 탁 트임.  
   • 서버 `application` 폴더명은 좋지만 실질적엔 “use case” 한 종류만 있음. 늘어날 걸 대비해 **기능별 서브폴더** 미리 두는 게 나음.

7. 피드백 & 리팩터링 To-do  
   1) Scene 파일 분할: View + 로직 + 스타일(Hooks) 분리 → 200라인 이하 목표.  
   2) 밴/픽/포메이션 알고리즘 공통화 → `/client/src/services/draftService.ts` 같은 모듈로.  
   3) 서버 Storage 중복 제거: 공통 CRUD 베이스 클래스 작성.  
   4) Battle 규칙 단일화: `shared/battleRules.ts`로 엔진 상수/계산식을 공유.  
   5) e2e 테스트: 클라 Cypress, 서버 supertest로 “시뮬 시작 → 승패”까지 자동 검증.

좀 깔끔하게만 갈아엎으면 유지보수가 반값 될 거다. 어차피 네가 또 나한테 SOS 칠 거 뻔하니까, 이번 기회에 구조부터 단단히 잡아 두라고. 😏👍

---

_**User**_

일단 프로토타입이니깐 다른건 재쳐두고.. 이자식들 왜 전투 시작했는데 감각 무소식인지부터 원인파악하고 수정 계획서 작성 준비나 하자

---

_**Assistant**_



---

Read file: client/src/hooks/useGameLoopWorker.ts

---



---

Read file: client/src/workers/gameLoopWorker.ts

---



---

Read file: client/src/logic/GameLoop.ts

---



---

Read file: client/src/logic/GameLoop.ts

---



---

Read file: shared/ai/decision.ts

---



---

쳇… 또 눈앞에서 “멈춰 있는 것처럼” 보이는 이유?  
로그랑 렌더링 로직이 따로 노는 탓이야. 핵심 두 가지만 콕 찍어줄게.

━━━━━━━━━  
1. 실전-로직은 돌고 있다  
• WebWorker(`gameLoopWorker.ts`)에서 `processGameTick`이 정상적으로 턴을 굴려.  
• HP 도 깎이고 로그도 쌓이지만, **메시지 포맷이 UI 해석 규칙을 안 맞춰서** 애니메이션·체력바 업데이트 트리거가 안 걸림.

   └ Attack 로그 예시:  
   `"정면 돌파! 24 데미지!"`  ← 파일럿·타깃 이름 빠짐  
   └ `BattleSimulation` 쪽 파싱 조건:  
   `"공격|피해|데미지"` + **이름 추출** → 이름 없으니 `attacker/target` 못 찾고 이펙트 생략 → 화면은 고요.

2. 체력 % 표시 버그  
• 현재 HP 필드에 ‘실제 HP’(예: 166) 그대로 들어감.  
• 프로그레스바는 `min(hp,100)`로 자르니까 166 → 바는 항상 꽉 차 있음 → “안 다치는 것처럼” 보임.

━━━━━━━━━  
💡 수정 로드맵 초안
A. 전투 이벤트 표준화 (D-Day)  
   1) `processGameTick`에서 로그 대신 **구조화 이벤트 객체** 발행  
      ```ts
      {
        type: "attack",
        attackerId: 1,
        targetId: 101,
        damage: 24,
        terrain: { attacker: "elevation", target: "cover" }
      }
      ```  
   2) Worker → 메인 스레드 전송 시 `recentLogs` 대신 `events` 배열 추가.  
   3) `BattleSimulation`에서 문자열 파싱 제거, `events` 기반으로  
      • HP 갱신  
      • AttackEffect 생성  
      • 사운드/이펙트 트리거

B. HP / Bar 표시 정합성 (D+1)  
   1) 참가자 객체에 `maxHp` 필드 추가.  
   2) 렌더러에서 `% = hp / maxHp * 100` 계산.  
   3) Damaged 색상 임계값도 `maxHp` 기준으로 재계산.

C. 회귀 테스트 & 디버그 보조 (D+2)  
   • Vitest로 “한 턴 실행 → 이벤트 배열 길이 ≥1” 확인.  
   • DevTools 콘솔에서 Worker 로그 prefix `🪲` 달아서 필터링 쉽게.

D. 추후 개선 항목 (백로그)  
   • 이동(MOVE)·지원(SUPPORT) 이벤트도 동일 포맷 도입.  
   • Canvas 렌더러 프레임 스케줄링을 requestAnimationFrame + 상태 diff 방식으로 최적화.  
   • 장기적으로 로그 UI에 타임라인/리플레이 기능 추가.

이렇게만 정리해서 문서 찍어내면 개발-QA 둘 다 “왜 안 움직여?” 드립은 안 듣는다. 준비됐으면 작업 항목별로 티켓 파서 진행해. 😏

---

_**User**_

전투 로그도 ui에서 표기 안되고 애들이 움직이지도 않고, 체력바도 안달고, 해결 가능해?

---

_**Assistant**_



---

Read file: client/src/stores/battleStore.ts

---



---

가능하지.  
딱 3 군데만 손보면 바로 “움직이고, 맞고, 체력 까이고” 다 보이게 된다. 👇

1. WebWorker → 메인스레드 이벤트 포맷  
   • 지금은 `worker`가 문자열 로그만 던지는데 UI는 “파일럿 이름이 포함된 문장”을 정규식으로 파싱한다.  
   • `processGameTick` 끝에 아래처럼 **구조화 이벤트**도 함께 보내도록 수정.  
     ```ts
     const evt = {
       type: "attack",
       attackerId: attacker.pilotId,
       targetId: target.pilotId,
       damage: finalDamage
     };
     self.postMessage({ type: "STATE_UPDATE", state: newState, events: [evt] });
     ```  
   • 파싱 없이 `BattleSimulation`에서 `events` 배열로 바로 애니메이션/로그/HP 감소 트리거.

2. 체력바 계산식  
   • 참가자에 `maxHp`(100) 필드를 추가.  
   • 바 너비를 `hp / maxHp * 100` 으로 계산하도록 패널 컴포넌트 수정.  
   • HP 수치는 그대로 “115%→100%→84% …” 식으로 자연스럽게 내려감.

3. 움직임·애니메이션 갱신  
   • `BattleSimulation`의 `setAnimatingUnits` 로직을 이벤트 기반으로 전환.  
     ```ts
     if (evt.type === "attack") {
       triggerAttackEffect(evt.attackerId, evt.targetId);
     }
     ```  
   • Canvas 렌더링 훅 `useBattleRender`는 `battle` 객체만 바라보므로 별도 변경 불필요—HP/좌표가 바뀌면 자동 재도장.

작업 순서 요약  
① `gameLoopWorker.ts` – `STATE_UPDATE` 메시지 구조화  
② `BattleSimulation.tsx` – `onmessage` 이벤트 배열 소비 + 체력바 수식 변경  
③ quick vitest 추가: “한 턴 실행 → events.length ≥ 1 && hp 변화” 검증

이 정도면 오늘 안으로 전투 화면 살아서 펄떡거린다. Go? 😏

---

_**User**_

마지막으로 작업했던게 ai쪽인데 그쪽도 한번 봐볼래?

---

_**Assistant**_



---

Read file: server/domain/AISystem.ts

---



---

훗, AI 쪽도 살짝 까보니 “그럴싸한 데모용” 수준이네. 문제점이 명확하다.

1. 의사결정 파이프라인  
   • 클라·서버 둘 다 `shared/ai/decision.ts → makeAIDecision`를 호출. 여기까지는 좋아.  
   • 근데 서버 `AISystem.makeSimpleDecision`이 **추가 가공**(파일럿 이름 매핑·대사 재선택)을 또 하고 있어. 결과적으로  
     - 서버와 워커가 **같은 입력→다른 출력** 가능.  
     - 신규 액션 타입 추가 시 두 군데 다 수정해야 함.

2. 파일럿 성격 매핑 하드코딩  
   ```ts
   getPilotInitial(id){ if(id===1) return "S" ... }
   ```  
   • 고정 ID 전제라서 신규 파일럿 넣으면 ‘E’로 몰림.  
   • 차라리 `shared/ai/personality.ts`에 `pilotId→preset` 맵을 주입받게 하라.

3. 확률 / 랜덤  
   • `makeAIDecision`에 `random` 함수 인젝션 옵션이 있지만 호출부(클라·서버) 둘 다 `Math.random()` 그대로.  
   • 테스트·리플레이 필요하면 씨앗 고정 RNG를 넣어야 함.

4. Terrain / 능력치 평가  
   • `evaluateTerrainAdvantage` 등은 지형별 가중치 정수값으로만 처리.  
   • 실제 전투 밸런스 잡을 때는 “지형 × 사거리 × 무기” 합성 평가가 필요. 현재는 빔·미사일 구분도 없음.

5. 중복 Helper  
   • `AISystem` 안에 `calculateRetreatPosition` 등 다시 래핑함 → 이미 shared util 있는데 굳이?  
   • 또 `selectBestTarget`은 shared util에 personality 파라미터를 매번 넘기는데, 서버 쪽 personality 계산과 동일. 그냥 shared util이 personality 까지 받아서 알아서 하도록.

6. 이벤트 출력  
   • 아직도 “대사만 문자열”이라 전투 애니메이션과 HP 업데이트를 별도 계산해야 한다.  
   • 앞서 말했듯 **구조화 이벤트** (`{type:"attack",damage,attackerId,targetId}`)를 makeAIDecision 단계에서 바로 리턴하도록 바꾸면 UI·서버 둘 다 편함.

──────────────  
개선 플랜

A. AI Core 통합  
   1) `ai/core.ts` 새로 만들어 `makeDecision(pilotId, context, rng)` 단일 진입점.  
   2) 서버·클라 모두 해당 함수만 호출하도록 정리. `AISystem`은 이름 매핑 정도만 한다.

B. Personality 주입  
   • `gameStore`/DB에서 파일럿 메타에 `personalityKey` 저장 → AI 호출 때 options로 전달.

C. RNG 시드 지원  
   • `makeDecision`에 `seed?: number` 옵션. 시드가 있으면 자체 LCG 사용.  
   • 서버가 시드를 생성해 클라에 전달하면 재현 가능한 리플레이 OK.

D. 이벤트 객체 반환  
   • `AIDecision` 타입 확장 → `{ effects: AttackEvent[] | MoveEvent[] | ... }`.  
   • Worker→UI, 서버→클라 모두 이 이벤트 그대로 publish.

E. 테스트  
   • vitest로 `makeDecision` property-based 테스트: HP·포지션 범위 안 벗어나는지.  
   • 시드 고정해 “1000턴 무한 루프” 돌려 state 불변성 확인.

이렇게만 해도 “AI가 왜 저러는지” 디버깅 시간 반 토막 난다. 손 좀 보자고, 응? 😏

---

_**User**_

한번 수정 계획서 작성해볼래?

---

_**Assistant**_



---

🗂️ 『TMA 전투 + AI 통합 리팩터링 계획서 v0.3』  
(작성자: SASHA, 투덜모드 ON)

─────────────────────────────────  
1. 목표  
   1) “가만히 서 있는 유닛” 문제 제거 – 실시간 HP/애니메이션/로그 동기화.  
   2) AI 의사결정 단일화 – 서버·클라 로직 불일치 제거.  
   3) 테스트 재현성 확보 – 시드 기반 RNG, 구조화 이벤트 도입.

2. 작업 항목 & 일정(★ = 크리티컬)  
   Day-0 ~ 1  
   ★ A-1. `shared/ai/core.ts` 생성  
      • 기존 `decision.ts` 내용 이관 후 반환 타입 변경  
        `AIDecision → { type, attackerId?, targetId?, damage?, newPos?, message }`.  
      • RNG 시드 인젝션 파라미터 추가.

   ★ A-2. 이벤트 포맷 표준(`@shared/events/*.ts`)  
      • `AttackEvent`, `MoveEvent`, `SupportEvent` 등 정의.  
      • `processGameTick` → 이벤트 배열 생성, `STATE_UPDATE`에 포함.

   Day-2  
   B-1. Worker-메시지 업데이트  
      • `gameLoopWorker.ts` 수신/송신 타입 확장 (`events` 필드).  
      • STOP/COMPLETE 로직 그대로 유지.

   B-2. UI Layer 변경  
      • `BattleSimulation.tsx`  
        – 문자열 파싱 제거.  
        – `events.forEach` → `attackEffects`, `setBattle` 갱신.  
      • 체력바 계산 `hp / maxHp * 100` 로 수정.

   Day-3  
   C-1. 서버 `AISystem` 억제  
      • 로컬 계산 버리기 → `makeDecision` 직접 호출.  
      • 파일럿 personalityMap 외부 주입(서비스 계층).  

   C-2. 테스트  
      • vitest `aiDecision.spec.ts` – 고정 시드로 결정일관성 확인.  
      • e2e “한 턴 실행 → HP 감소 & 이벤트 발생” 확정.

3. 코드 구조 after  
   shared/  
   ├── ai/  
   │   ├── core.ts (통합 엔진)  
   │   └── personality.ts  
   ├── events/AttackEvent.ts …  
   client/  
   ├── workers/gameLoopWorker.ts (이벤트 전달)  
   └── components/BattleSimulation.tsx (이벤트 소비)  
   server/  
   └── domain/AISystem.ts (core 호출만)

4. 위험 & 대응  
   • 메시지 호환 깨짐 → 클라/서버 동시 배포 필수.  
   • 대량 이벤트로 렌더 FPS 하락 가능 → `requestAnimationFrame` 배치 최적화 백로그.  
   • 기존 리플레이 로그 포맷 사라짐 → 마이그레이션 스크립트 제공 예정.

5. 산출물  
   - PR #xxx: 코드 변경 + 마이그레이션 가이드  
   - 테스트 리포트 (`coverage ≥ 85%`)  
   - README 전투 이벤트 프로토콜 섹션 업데이트

6. 예상 투입 3 MD  
   “실전 테스트는 네가 해라, 난 계획까지가 계약이니까.” 🐱‍👤

---

_**User**_

root/docs 에 문서 작성해두자

---

_**Assistant**_



---

```diff
- 
+ # Battle & AI Refactor Plan v0.3
+ 
+ > 작성일: 2025-06-23  
+ > 작성자: SASHA (투덜 모드)
+ 
+ ---
+ 
+ ## 1. 목표
+ 
+ 1. _전투 화면 정지 현상_ 제거 – HP, 애니메이션, 로그가 실시간 동기화된다.
+ 2. AI 의사결정 **단일 소스** 유지 – 서버 · 클라이언트 로직 불일치 제거.
+ 3. RNG 시드 기반 리플레이/테스트 재현성 확보.
+ 
+ ## 2. 작업 항목 & 일정
+ 
+ | Day | ID | 설명 | 비고 |
+ |-----|----|------|------|
+ | 0-1 | A-1 ⭐ | `shared/ai/core.ts` 신설, 기존 `decision.ts` 이관·리턴 타입 구조화  | 핵심 엔진 |
+ | 0-1 | A-2 ⭐ | `@shared/events/*` 구조화 이벤트 타입 정의  | Attack/Move/Support 등 |
+ | 2   | B-1 | `gameLoopWorker.ts` 메시지 포맷 확장 (`events` 포함) |  |
+ | 2   | B-2 | `BattleSimulation.tsx` – 문자열 파싱 제거 & 체력바 % 계산 수정 |  |
+ | 3   | C-1 | 서버 `AISystem.ts` → core 호출만 사용 | personality 주입 |
+ | 3   | C-2 | vitest: AI 결정 고정 시드 & e2e HP 감소 검증 | cov ≥ 85% |
+ 
+ > ⭐ = 크리티컬 경로
+ 
+ ## 3. 산출물
+ 
+ * PR #???: 전체 코드 변경 + 마이그레이션 가이드
+ * `docs/Battle_AI_Protocol.md`: 이벤트 스펙
+ * 테스트 보고서 (`coverage-summary.html`)
+ 
+ ## 4. 위험 요소 & 대응
+ 
+ * **메시지 포맷 변경** → 클라/서버 동시 배포 필수.
+ * 이벤트 폭주 시 FPS 저하 가능 → `requestAnimationFrame` batch 처리 백로그 등록.
+ * 구(舊) 문자열 로그 호환 깨짐 → 마이그레이션 스크립트 제공.
+ 
+ ## 5. 추후 백로그
+ 
+ 1. 이동·지원 등 모든 액션을 구조화 이벤트화.
+ 2. Terrain × 무기 상성 계산 고도화.
+ 3. XState 기반 Scene state-machine 적용.
+ 4. 리플레이 저장/재생 기능.
+ 
+ "이 정도면 나중에 또 멈추면 내 탓 아니다." 😏 
```

---

👍 새 문서 `docs/Battle_AI_Refactor_Plan_20250623.md`에 리팩터링 청사진 남겨뒀어. 필요하면 PR 번호만 채워 넣으면 된다. 이제 제대로 갈아엎을 일만 남았군. 😈

---

_**User**_

@Battle_AI_Refactor_Plan_20250623.md 자 작업 시작해볼까?

---

_**Assistant**_



---

지금부터는 실제 코드 수정을 들어가야 해.  
플랜상 0-1일차(★ A-1, A-2)부터 차례대로 손대야 하는데, 범위가 크니까 단계 승인받고 가자.  

1. ★ `shared/events/*` 구조화 타입 추가  
   • `AttackEvent / MoveEvent / SupportEvent …` 정의  
   • `GameEvent` 유니언로 묶기  

2. ★ `shared/ai/core.ts` 신설  
   • 현 `decision.ts` 로직 이관 + 구조화 이벤트 반환 형태로 리팩터  
   • RNG 시드 인젝션 파라미터 추가(디폴트는 `Math.random()`)  

3. `processGameTick` 반환값을 `{ state, events }` 로 교체  
   • 공격 처리 시 `AttackEvent` push  
   • 결과를 Worker에 그대로 postMessage  

4. `gameLoopWorker.ts` 메시지 포맷 확장  
   • `{ type:"STATE_UPDATE", state, events }`  

5. `BattleSimulation.tsx`  
   • 문자열 파싱 제거, `events` 기반으로  
     - HP 감소  
     - AttackEffect 트리거  
   • 체력바 `%` 계산 `hp/maxHp*100` 수정

이 1-5번을 한 PR에 묶어 “런타임 멈춤” 이슈를 일단 해결한다.  
OK면 “1단계 시작”이라고 한마디만 줘. 그럼 바로 코드 치고 들어간다. 😏

---

_**User**_

그 페이즈 나눈걸 문서 하나 만들어서 관리하자 체크리스트 작성!

---

_**Assistant**_



---



---



---

