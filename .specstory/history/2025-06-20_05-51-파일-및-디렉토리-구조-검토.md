<!-- Generated by SpecStory -->

# 파일 및 디렉토리 구조 검토 (2025-06-20 14:51:05)

_**User**_

@/src @index.html @/server 구조 쭉 봐보자

---

_**Assistant**_



---

흥, 대충 이런 식으로 파일이 깔려있어. (헷갈리지 않게 상위 → 하위 순서로 정리했으니까 눈 크게 뜨고 봐.)

1. 프로젝트 루트  
   • client/ – 전부 프론트엔드. React + Vite + Tailwind.  
   • server/ – 백엔드. Express 기반에 전투 로직(`domain/`, `application/`)과 인-메모리/SQLite 스토리지.  
   • shared/ – 타입 정의 및 공용 util.  
   • docs/, images/, tests 등 기타 잡동사니.

2. client/  
   ├─ index.html – Vite 진입점. `<div id="root" />`에 React 마운트, 구글 폰트·리플릿 배너 정도만 있음.  
   ├─ src/  
   │  ├─ App.tsx → 라우터 + 전역 Provider 모음  
   │  ├─ main.tsx → ReactDOM.createRoot, Tailwind 초기화  
   │  ├─ components/  
   │  │  ├─ GameShell.tsx → 전체 UI 프레임 (헤더·사이드바·푸터)  
   │  │  ├─ BattleSimulation.tsx → 캔버스 전투 시뮬 + AI 의사결정  
   │  │  └─ scenes/ → 허브·스카우팅·밴픽·편성·전투 등 “게임 화면” 모듈별 분할  
   │  ├─ hooks/ – 반응형 util(`use-mobile` 등)  
   │  ├─ lib/ – queryClient, websocket 매니저 등 네트워크·헬퍼  
   │  ├─ stores/ – zustand 스토어(`gameStore`, `battleStore`)  
   │  └─ presentation/ – CanvasRenderer 같은 추상 뷰  
   └─ index.css – 전역 테마 + 커스텀 스크롤바 + cyber-border 같은 클래스

3. server/  
   ├─ domain/  
   │  • AISystem.ts – 전투 AI 결정 로직  
   │  • BattleEngine.ts – 턴 루프 & 승패 판단  
   ├─ application/  
   │  • BattleUseCase.ts – 엔진 래핑해서 initialize/run  
   ├─ storage.ts (interface)  
   ├─ MemStorage.ts / SQLiteStorage.ts – 개발/프로덕션 스토리지 구현  
   ├─ routes.ts – REST 엔드포인트 등록  
   ├─ index.ts – Express 부트스트랩 + Vite 미들웨어  
   └─ vite.ts – dev 서버 헬퍼 & 정적 파일 서빙

4. index.html (client/index.html) 요약  
```1:17:client/index.html
<!DOCTYPE html>
<html lang="en">
  <head> … 구글 폰트 링크 & 메타태그 … </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```
딱히 특별할 건 없고, 그냥 Vite 기본 템플릿에 폰트랑 배너만 추가.

결론?  
• 화면 단은 `client/src/components/scenes/*` 에서 전부 관리.  
• 실시간 전투 로직은 `BattleSimulation.tsx` 가 캔버스로 그리며, 간단 AI는 `shared/ai/utils` 사용.  
• 백엔드는 `server/domain` 에 핵심 로직, `application` 계층이 유즈케이스, `routes.ts` 로 노출.  
• 타입·스키마는 `shared/` 와 `server/*Storage.ts` 가 공유.

필요한 부분 더 까줘야 하면 불러.

---

_**User**_

전투 시뮬쪽 개선여지가 있다고 생각하는데 어떻게 봐

---

_**Assistant**_



---

흥, 눈에 보이는 문제만 대충 찍어도 이 정도야. (너도 알겠지만 내 잔소리는 서비스니까 잘 새겨둬.)

1. 덩치부터 줄여  
   • `BattleSimulation.tsx` 1 000줄 넘는 괴수 컴포넌트. 렌더·AI·상태 업데이트·UI 로직이 한데 뒤섞여서 가독성⁄테스트성 쓰레기야.  
   → 캔버스 렌더러, 게임 루프, AI 결정, 이펙트 매니저를 별도 훅/모듈로 쪼개. 최소 SRP.

2. 게임 루프 구조  
   • `setInterval(…, 1000)`로 틱 돌리면서 React state를 매초 갈아엎고 있지? → 리렌더 폭탄 + FPS 저하.  
   • 렌더 사이클(requestAnimationFrame)과 논리 틱을 분리해.  
   • 로직 틱은 Web Worker로 빼면 UI 스레드 안 끊겨.

3. 상태 관리  
   • `animatingUnits`, `attackEffects`를 `useState`로 들고 있으니 매 프레임 배열 새로 생성 → GC 압박.  
   → `useRef`+임퍼러티브 머트니션(애니메이션 내부 배열) or Object Pool.

4. AI & 밸런스  
   • 지금은 랜덤 + 퍼스낼리티 가중치만.  
     – 승패 예측 못 함, 난이도 조절도 힘들어.  
   • 개선안:  
     a. 서버 측 `AISystem` 로직을 공유(or Web Worker)해서 결정 일원화.  
     b. 상태평가(utility value) + 행동 스코어링으로 deterministic decision 가능.  
     c. 난이도는 가중치 스케일링으로 조정.

5. 네트워크/멀티플레이 확장성  
   • 클라에서 결과를 ‘진실’로 결정해서 서버에 로그만 남기면 치팅 여지.  
   • 핵심 판정은 서버에서, 클라는 결과만 재생(Authority Server). 추후 PVP 염두에 두면 필수.

6. 캔버스 렌더  
   • 매 프레임 지형 그리기 ⇒ 변하지 않는 레이어는 별도 off-screen 캐시.  
   • 텍스트 `fillText` 반복 호출 비싼 거 알지? 파일럿 이름은 DOM 오버레이로 빼거나 스프라이트화.  
   • 고해상도 디스플레이에선 DPR 고려해서 `canvas.width = logical*devicePixelRatio`.

7. 이펙트 시스템  
   • `attackEffects` 끝나면 필터해서 배열 재생성 → O(n²) 성장 위험.  
   • ID 기반 맵 & 풀링, 재사용으로 줄여.

8. 테스트 & 디버그  
   • 현재 시뮬에 대한 단위/통합 테스트 전무.  
   • 로직 분리 후 vitest로 AI 결정과 승패 판정 케이스 작성해두면 회귀 방지.

9. 타입 엄격화  
   • 몇몇 `any`, `as const` 남발.  
   • `BattleParticipant`, `BattleState`는 shared 타이핑으로 올려서 클라·서버 동기화.

10. UX 자잘한 것  
    • 카운트다운·승리 UI를 별도 컴포넌트로 빼서 재사용.  
    • HP 0%일 때 파괴 애니메이션(폭발) 추가하면 눈맛 ↑  
    • 지형 효과 툴팁: 마우스 hover→효과 설명.

정리-말?  
코어 개선 순서 추천  
① 컴포넌트 분할 → ② 논리 tick/web-worker 이관 → ③ AI 알고리즘 고도화 → ④ 렌더 최적화 → ⑤ 서버-권한 구조.  

…이 정도면 “전투 시뮬 v2” 로고 붙여도 되겠지. 귀찮아도 하나씩 갈아엎어 봐. 😏

---

_**User**_

그래 이런 대답을 원했어 ㅋㅋ 리팩토리 계획안 문서 작성해줘 @/docs 여따가. 디렉토리 보는김에 거기 문서들도 읽어보고

---

_**Assistant**_



---

Could not find file 'docs/refactoring_plan.md' in the workspace.

---



---

<details>
            <summary>Listed directory docs • **7** results</summary>
        
| Name |
|-------|
| 📄 `Trinity_Mecha_Academy_Story_Background_1750379596494.md` |
| 📄 `Trinity_Mecha_Academy_Story_Background_1750353437815.md` |
| 📄 `Trinity_Mecha_Academy_Game_Design_1750379596492.md` |
| 📄 `TMA_TFM_Integration_Guide_1750379596496.md` |
| 📄 `TMA_Reference_Games_1750379596496.md` |
| 📄 `TMA_Development_Roadmap_1750379596495.md` |
| 📄 `TMA_Core_Game_Design_1750379596495.md` |

</details>

---



---

```diff
- 
+ # 🛠️ Battle Simulation Refactoring Plan (v2025-06-20)
+ 
+ > **대상 모듈**: `client/src/components/BattleSimulation.tsx` 및 관련 로직 (`shared/ai/utils`, `stores/battleStore`, `presentation/CanvasRenderer` 등)
+ >
+ > **작성자**: SASHA (AI 파트너)
+ 
+ ---
+ 
+ ## 1. Refactor 목적
+ 1. **가독성 향상** – 1,000+ 라인 복합 컴포넌트를 SRP 단위로 분리.
+ 2. **성능 최적화** – 렌더 루프와 게임 로직 분리, 불필요한 React state 재렌더 제거.
+ 3. **테스트 용이성** – AI 결정·전투 판정 로직을 pure function/worker 로 이동하여 Vitest 단위 테스트 적용.
+ 4. **확장성 확보** – 서버 권한 구조(Authoritative Server)와 Web Worker 확장 대비.
+ 
+ ## 2. 현황 문제점 🔍
+ | 카테고리 | 증상 |
+ | --- | --- |
+ | 구조 | UI · 게임루프 · AI · 이펙트가 단일 파일에 혼재 |
+ | 성능 | `setInterval` + `useState` 남발 → 과도한 리렌더 & GC |
+ | 테스트 | 비동기·랜덤 의존 → 단위 테스트 작성 난이도 높음 |
+ | 확장 | 멀티플레이/PVP 전환 시 클라 판정 구조가 병목 |
+ 
+ ## 3. 목표 아키텍처 🏗️
+ ```mermaid
+ flowchart TD
+   subgraph UI Thread
+     A[BattleSimulation (Presenter)]
+     A -->|props| CanvasRenderer
+     A -->|hook| useBattleRender
+   end
+ 
+   subgraph Worker "Game Worker Thread"
+     B[GameLoop.ts] --> C[AISystem.ts]
+     B --> D[EffectManager.ts]
+   end
+ 
+   battleStore <--> B
+   battleStore <--> A
+ ```
+ 
+ * **GameLoop.ts (Worker)** – 60 FPS or △1s logic tick, postMessage 로 state diff 송신
+ * **AISystem.ts** – decision core (공유 코드 /server/domain/AISystem.ts 재사용)
+ * **EffectManager.ts** – 공격 이펙트 풀링 & lifecycle 관리
+ * **useBattleRender** – CanvasLayer pre-render 캐싱, DPR 대응
+ 
+ ## 4. 단계별 작업 🗂️
+ 
+ ### Phase A) 모듈 분리 (1~2일)
+ - [ ] `BattleSimulation.tsx` → Presenter 역할만 남기고 로직 제거
+ - [ ] `hooks/useBattleRender.ts` 신설 – 캔버스 드로잉 전담
+ - [ ] `logic/GameLoop.ts` 작성 – 기존 tick 로직 이관
+ 
+ ### Phase B) Web Worker 도입 (2~3일)
+ - [ ] Vite `worker` 플러그인 설정
+ - [ ] GameLoop + AI 로 Worker 구동, postMessage API 설계
+ - [ ] 메인 스레드와 상태 sync (immer patch or diff)
+ 
+ ### Phase C) AI 결정 통합 (2일)
+ - [ ] `/shared/ai` → `/shared/ai/decision.ts` 로 추상화
+ - [ ] 서버 `domain/AISystem.ts` 코드 공유 (ts-paths alias)
+ 
+ ### Phase D) 렌더 최적화 (1~2일)
+ - [ ] 지형 레이어 off-screen canvas 캐싱
+ - [ ] 텍스트 Overlay DOM 분리 (파일럿 이름/HP)
+ - [ ] DPR(scale) 지원 & resize debounce
+ 
+ ### Phase E) 테스트 & 문서 (1일)
+ - [ ] Vitest: AI decision, victory condition, tick timing
+ - [ ] Storybook(or simple page) for CanvasRenderer demo
+ - [ ] README 업데이트
+ 
+ > 총 소요: **약 8~10 dev-days** (버퍼 포함 2주)
+ 
+ ## 5. 작업 체크리스트 ☑️
+ - [ ] eslint 통과 & 기존 lint rule 유지
+ - [ ] vitest 90%+ 커버리지 (AI/Tick)
+ - [ ] 게임 플레이 기존 기능 100% 유지 (회귀 테스트)
+ - [ ] Lighthouse FPS > 55 on mid-range laptop
+ 
+ ## 6. 위험 & 대응 🚧
+ | 위험 | 대응 |
+ | --- | --- |
+ | Worker 메시지 병목 | diff 최소화, transferable object 사용 |
+ | 동기화 버그 | redux-devtools style time-travel 디버그 도구 적용 |
+ | 일정 지연 | 단계별 Merge Request & 피드백, 롤백 스위치 유지 |
+ 
+ ## 7. 로드맵 매핑 📅
+ * **Phase 1.3 통신 로그 시스템** – 렌더 분리 후 Overlay 확장 용이
+ * **Phase 2.1 밴픽 시스템** – 서버 authoritative 구조 전제
+ * **Phase 4.1 고급 AI** – Worker 구조 위에 ML/BT 확장 배치
+ 
+ ## 8. 완료 기준 ✅
+ 1. `BattleSimulation.tsx` 라인 수 250↓.
+ 2. 메인 쓰레드 FPS 향상(>+20%).
+ 3. vitest 전투 시뮬 단위 테스트 20개 이상 통과.
+ 4. Roadmap Phase 1 남은 태스크(1.2, 1.3) 개발에 지장 없음 증명.
+ 
+ ---
+ 
+ > **다음 액션**: 코드 리팩토링 Branch `feature/refactor-battle-sim` 생성 후 Phase A 착수. 
```

---

됐어. `docs/BattleSimulation_Refactor_Plan_20250620.md`에 전체 리팩토링 로드맵, 단계별 작업·아키텍처 다 작성해 놨어.  
(눈팅해 보고 빠진 건 또 찔러줘.)

---

_**User**_

충분하네! 테스크매니저 리퀘스트 작성하자 문서 기반으로@BattleSimulation_Refactor_Plan_20250620.md 

---

_**Assistant**_



---



---

테스크 등록 완료. 이제 `get_next_task` 호출해서 첫 번째 작업(task-132: 브랜치 생성 & 베이스라인)을 가져오면 돼. 진행할 때마다 작업 완료 마킹 → 내 승인 루틴 잊지 말고.

---

