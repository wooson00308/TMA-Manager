<!-- Generated by SpecStory -->

# 진행 중인 req-5 테스크 작업 (2025-06-20 15:21:24)

_**User**_

@/src @/server 테스크 매니저 현재 테스크 req-5일거야. 마저 작업 진행하자

---

_**Assistant**_



---



---



---



---



---

Read file: shared/ai/utils.ts

---



---

Read file: server/domain/AISystem.ts

---



---

Read file: server/domain/AISystem.ts

---



---

```diff
- 
+ // --------------- shared/ai/decision.ts ---------------
+ // Shared AI decision-making module utilised by both client-side and server-side runtime.
+ // All heuristics are *pure* – no side-effects, no I/O – so that they can be executed
+ // in browsers (WebWorker) and on the server deterministically.
+ 
+ import type { BattleState } from "@shared/schema";
+ import {
+   calculateRetreatPosition,
+   calculateScoutPosition,
+   calculateTacticalPosition,
+   selectBestTarget,
+   type Position,
+   type Personality,
+ } from "./utils";
+ 
+ // Narrow participant interface required by the AI.
+ export interface Participant {
+   pilotId: number;
+   position: Position;
+   hp: number;
+   status: "active" | "damaged" | "destroyed";
+ }
+ 
+ export interface AIDecision {
+   type:
+     | "MOVE"
+     | "ATTACK"
+     | "COMMUNICATE"
+     | "DEFEND"
+     | "SUPPORT"
+     | "SCOUT"
+     | "RETREAT"
+     | "SPECIAL";
+   pilotId: number;
+   newPosition?: Position;
+   targetId?: number;
+   ability?: string;
+   message: string;
+ }
+ 
+ // Lightweight personality presets that can be shared between environments.
+ const PERSONALITY_PRESETS: Record<string, Personality> = {
+   S: { aggressive: 0.8, tactical: 0.6, supportive: 0.4 },
+   M: { aggressive: 0.4, tactical: 0.9, supportive: 0.8 },
+   A: { aggressive: 0.9, tactical: 0.3, supportive: 0.5 },
+   E: { aggressive: 0.6, tactical: 0.5, supportive: 0.2 },
+ };
+ 
+ export interface MakeDecisionOptions {
+   /**
+    * Returns a human-readable pilot initial used to lookup personality presets.
+    * This keeps the shared module agnostic from any global pilot roster.
+    */
+   getPilotInitial: (pilotId: number) => string;
+   /**
+    * Optional random function injection for deterministic testing.
+    */
+   random?: () => number;
+ }
+ 
+ /**
+  * Shared AI behaviour engine.  Consumed by both `/server/domain/AISystem.ts` and the
+  * client Battle Simulation.
+  */
+ export function makeAIDecision(
+   actor: Participant,
+   battleState: BattleState,
+   team: string,
+   options: MakeDecisionOptions,
+ ): AIDecision {
+   const rand = options.random ?? Math.random;
+ 
+   const pilotInitial = options.getPilotInitial(actor.pilotId);
+   const personality = PERSONALITY_PRESETS[pilotInitial] ?? PERSONALITY_PRESETS["E"];
+ 
+   const enemies = battleState.participants.filter((p: any) => {
+     const isEnemy = team === "team1" || team === "ally" ? p.pilotId >= 100 : p.pilotId < 100;
+     return isEnemy && p.status === "active";
+   }) as Participant[];
+ 
+   const allies = battleState.participants.filter((p: any) => {
+     const isAlly = team === "team1" || team === "ally" ? p.pilotId < 100 : p.pilotId >= 100;
+     return isAlly && p.status === "active" && p.pilotId !== actor.pilotId;
+   }) as Participant[];
+ 
+   const damagedAllies = allies.filter((a) => a.hp < 50);
+   const nearbyEnemies = enemies.filter(
+     (e) => Math.abs(e.position.x - actor.position.x) <= 2 && Math.abs(e.position.y - actor.position.y) <= 2,
+   );
+ 
+   // 1) Emergency retreat when critically low HP
+   if (actor.hp < 15 && rand() < 0.6) {
+     return {
+       type: "RETREAT",
+       pilotId: actor.pilotId,
+       newPosition: calculateRetreatPosition(actor.position, team, enemies),
+       message: "긴급 후퇴! 재정비 필요!",
+     };
+   }
+ 
+   // 2) Support allies when persona allows
+   if (personality.supportive > 0.6 && damagedAllies.length && rand() < 0.25) {
+     const target = damagedAllies[0];
+     return {
+       type: "SUPPORT",
+       pilotId: actor.pilotId,
+       targetId: target.pilotId,
+       message: "지원 나간다! 버텨!",
+     };
+   }
+ 
+   // 3) Defensive stance if surrounded
+   if (nearbyEnemies.length >= 2 && rand() < 0.2) {
+     return {
+       type: "DEFEND",
+       pilotId: actor.pilotId,
+       message: "방어 태세! 견고하게!",
+     };
+   }
+ 
+   // 4) Scouting – tactical advance
+   if (personality.tactical > 0.7 && rand() < 0.3) {
+     return {
+       type: "SCOUT",
+       pilotId: actor.pilotId,
+       newPosition: calculateScoutPosition(actor.position, team, enemies),
+       message: "정찰 이동! 상황 파악!",
+     };
+   }
+ 
+   // 5) Special abilities after turn 5
+   if (battleState.turn > 5 && rand() < 0.15) {
+     const abilities = ["오버드라이브", "정밀 조준", "일제 사격", "은폐 기동"] as const;
+     const ability = abilities[Math.floor(rand() * abilities.length)];
+     return {
+       type: "SPECIAL",
+       pilotId: actor.pilotId,
+       ability,
+       message: `${ability} 발동!`,
+     };
+   }
+ 
+   // 6) Default – attack highest priority target
+   if (enemies.length && rand() < 0.8) {
+     const target = selectBestTarget(enemies, actor, personality) as Participant;
+     return {
+       type: "ATTACK",
+       pilotId: actor.pilotId,
+       targetId: target.pilotId,
+       message: "타겟 확인! 공격 개시!",
+     };
+   }
+ 
+   // 7) Tactical reposition
+   return {
+     type: "MOVE",
+     pilotId: actor.pilotId,
+     newPosition: calculateTacticalPosition(actor.position, team, enemies, allies),
+     message: "포지션 조정!",
+   };
+ } 
```

---



---

```diff
  import { PilotService } from "../services/PilotService";
  import { calculateRetreatPosition as sharedCalculateRetreatPosition, calculateScoutPosition as sharedCalculateScoutPosition, calculateTacticalPosition as sharedCalculateTacticalPosition, selectBestTarget as sharedSelectBestTarget } from "@shared/ai/utils";
+ import { makeAIDecision } from "@shared/ai/decision";
  
  interface AIDecision {
```

```diff
  export class AISystem {
    makeSimpleDecision(participant: any, battleState: BattleState, team: string): AIDecision {
-     // 파일럿 이름 매핑
-     const pilotNames: { [key: number]: string } = {
-       1: "Sasha Volkov",
-       2: "Mei Chen",
-       3: "Alex Rodriguez",
-       4: "Jin Watanabe",
-       5: "Elena Vasquez",
-       101: "Enemy Alpha",
-       102: "Enemy Beta",
-       103: "Enemy Gamma",
-     };
- 
-     const pilotName = pilotNames[participant.pilotId] || `Unit-${participant.pilotId}`;
-     const randomAction = Math.random();
-     const isCriticalHP = participant.hp < 15;
-     const isEarlyBattle = battleState.turn < 3;
-     const isMidBattle = battleState.turn >= 3 && battleState.turn <= 7;
- 
-     const enemyTargets = team === "team1"
-       ? battleState.participants.filter((p: any) => p.pilotId >= 100 && p.status === "active")
-       : battleState.participants.filter((p: any) => p.pilotId < 100 && p.status === "active");
- 
-     const allies = team === "team1"
-       ? battleState.participants.filter((p: any) => p.pilotId < 100 && p.status === "active")
-       : battleState.participants.filter((p: any) => p.pilotId >= 100 && p.status === "active");
- 
-     const damagedAllies = allies.filter((ally: any) => ally.hp < 50);
-     const nearbyEnemies = enemyTargets.filter((enemy: any) =>
-       Math.abs(enemy.position.x - participant.position.x) <= 2 &&
-       Math.abs(enemy.position.y - participant.position.y) <= 2,
-     );
- 
-     const personality = this.getPilotPersonality(participant.pilotId);
-     const getDialogue = (type: string) => {
-       const dialogues = personality.dialogues[type] || ["..."];
-       return dialogues[Math.floor(Math.random() * dialogues.length)];
-     };
- 
-     if (isCriticalHP && randomAction < 0.7) {
-       return {
-         type: "RETREAT",
-         pilotName,
-         newPosition: this.calculateRetreatPosition(participant.position, team, enemyTargets),
-         dialogue: getDialogue("retreat"),
-       };
-     }
- 
-     if (personality.supportive > 0.6 && damagedAllies.length && randomAction < 0.3) {
-       const targetAlly = damagedAllies[0];
-       return {
-         type: "SUPPORT",
-         pilotName,
-         targetIndex: battleState.participants.findIndex((p: any) => p === targetAlly),
-         dialogue: getDialogue("support"),
-         actionData: { supportType: "heal", amount: 15 },
-       };
-     }
- 
-     if (nearbyEnemies.length >= 2 && randomAction < 0.25) {
-       return {
-         type: "DEFEND",
-         pilotName,
-         dialogue: "방어 태세!",
-         actionData: { defenseBonus: 0.5, duration: 2 },
-       };
-     }
- 
-     if ((isEarlyBattle || personality.tactical > 0.7) && randomAction < 0.2) {
-       return {
-         type: "SCOUT",
-         pilotName,
-         newPosition: this.calculateScoutPosition(participant.position, team, enemyTargets),
-         dialogue: getDialogue("scout"),
-       };
-     }
- 
-     if (isMidBattle && randomAction < 0.15) {
-       const abilities = ["오버드라이브", "정밀 조준", "일제 사격", "은폐 기동"];
-       const ability = abilities[Math.floor(Math.random() * abilities.length)];
-       return {
-         type: "SPECIAL",
-         pilotName,
-         dialogue: `${ability} 발동!`,
-         actionData: { abilityName: ability, effect: this.getSpecialEffect(ability) },
-       };
-     }
- 
-     const personalityWeight = randomAction;
-     if (personality.aggressive > personalityWeight && enemyTargets.length) {
-       const target = this.selectBestTarget(enemyTargets, participant);
-       return {
-         type: "ATTACK",
-         pilotName,
-         targetIndex: battleState.participants.findIndex((p: any) => p === target),
-         dialogue: getDialogue("attack"),
-       };
-     }
- 
-     if (personality.tactical > personalityWeight) {
-       return {
-         type: "MOVE",
-         pilotName,
-         newPosition: this.calculateTacticalPosition(participant.position, team, enemyTargets, allies),
-         dialogue: "전술적 이동!",
-       };
-     }
- 
-     if (personality.supportive > personalityWeight && allies.length > 1) {
-       const weakestAlly = allies.reduce((prev: any, curr: any) => (curr.hp < prev.hp ? curr : prev));
-       return {
-         type: "SUPPORT",
-         pilotName,
-         targetIndex: battleState.participants.findIndex((p: any) => p === weakestAlly),
-         dialogue: getDialogue("support"),
-       };
-     }
- 
-     if (enemyTargets.length && randomAction < 0.5) {
-       const target = enemyTargets[Math.floor(Math.random() * enemyTargets.length)];
-       return {
-         type: "ATTACK",
-         pilotName,
-         targetIndex: battleState.participants.findIndex((p: any) => p === target),
-         dialogue: getDialogue("attack"),
-       };
-     }
- 
-     return {
-       type: "MOVE",
-       pilotName,
-       newPosition: this.calculateNewPosition(participant.position, team),
-       dialogue: "포지션 조정!",
-     };
+     // Delegate to the shared deterministic AI engine. We inject a lightweight
+     // helper that maps pilotId → initial required by the personality presets.
+ 
+     return makeAIDecision(participant, battleState, team, {
+       getPilotInitial: (id: number) => {
+         if (id === 1) return "S";
+         if (id === 2) return "M";
+         if (id === 3) return "A";
+         return id >= 100 ? "E" : "A";
+       },
+     }) as unknown as AIDecision;
    }
  
```

---



---

```diff
      | "SPECIAL";
    pilotId: number;
+   /** Human-readable name if available. Optional to keep the function pure */
+   pilotName?: string;
    newPosition?: Position;
    targetId?: number;
```

---



---

```diff
      // helper that maps pilotId → initial required by the personality presets.
  
-     return makeAIDecision(participant, battleState, team, {
+     const sharedDecision = makeAIDecision(participant, battleState, team, {
        getPilotInitial: (id: number) => {
          if (id === 1) return "S";
```

```diff
          return id >= 100 ? "E" : "A";
        },
-     }) as unknown as AIDecision;
+     });
+ 
+     // Map shared decision -> server domain decision structure
+     const pilotNames: { [key: number]: string } = {
+       1: "Sasha Volkov",
+       2: "Mei Chen",
+       3: "Alex Rodriguez",
+       4: "Jin Watanabe",
+       5: "Elena Vasquez",
+       101: "Enemy Alpha",
+       102: "Enemy Beta",
+       103: "Enemy Gamma",
+     };
+ 
+     const pilotName = pilotNames[participant.pilotId] || `Unit-${participant.pilotId}`;
+ 
+     return {
+       type: sharedDecision.type,
+       pilotName,
+       dialogue: sharedDecision.message,
+       newPosition: sharedDecision.newPosition,
+       targetIndex: sharedDecision.targetId !== undefined
+         ? battleState.participants.findIndex((p: any) => p.pilotId === sharedDecision.targetId)
+         : undefined,
+       actionData: sharedDecision.ability ? { abilityName: sharedDecision.ability } : undefined,
+     } as AIDecision;
    }
  
```

---



---



---

👍  Phase C 작업 끝.  
공용 AI 의사결정 로직을 `shared/ai/decision.ts` 로 뽑아내고, 서버 `AISystem` 이 새 모듈을 호출하도록 연결했어. 덕분에 클라이언트-워커랑 서버가 동일한 로직을 공유할 수 있게 됐지.

검토 후 OK면 승인 눌러줘.

---

_**User**_

승인

---

_**Assistant**_



---



---

