import { makeAIDecision as originalMakeAIDecision, type Participant as OriginalParticipant, type AIDecision as OriginalAIDecision, type MakeDecisionOptions as OriginalOptions } from "./decision";
import type { BattleState } from "@shared/schema";
import type { GameEvent } from "@shared/events";

// Simple deterministic PRNG (mulberry32)
function mulberry32(seed: number): () => number {
  return function () {
    let t = (seed += 0x6d2b79f5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

export interface MakeDecisionOptions extends OriginalOptions {
  /**
   * Deterministic RNG seed. If provided and no custom random() is passed,
   * a seeded PRNG will be injected automatically so that AI decisions become
   * fully reproducible (useful for tests and replays).
   */
  seed?: number;
}

export type Participant = OriginalParticipant;

export type AIDecision = OriginalAIDecision & {
  /**
   * Structured events generated by the decision.  Consumers (client worker, server engine)
   * can enqueue these into their event queues instead of parsing raw logs.
   */
  events: GameEvent[];
};

export function makeAIDecision(
  actor: Participant,
  battleState: BattleState,
  team: string,
  options: MakeDecisionOptions,
): AIDecision {
  const { seed, ...rest } = options;

  // Inject seeded RNG if necessary
  const opts: OriginalOptions = {
    ...rest,
    random: seed !== undefined && !rest.random ? mulberry32(seed) : rest.random,
  };

  const baseDecision = originalMakeAIDecision(actor, battleState, team, opts);

  // TODO: Translate baseDecision into concrete GameEvents.
  // For now, we return an empty array to satisfy type contract.
  return { ...baseDecision, events: [] } as AIDecision;
} 